##五、类的其它知识点
###1.1类方法和静态方法
1. 类方法
* 定义：使用装饰器@classmethod。第一个参数必须是当前类对象，该参数名一般约定为“cls”，通过它来传递类的属性和方法（不能传实例的属性和方法）；
* 调用：实例对象和类对象都可以调用。
* 作用：内部或外部需要用到类的属性或方法的时候
#####例子：
```cython
class Student:

    __count = 0

    def __init__(self, name, age):
        self.name = name
        self.age = age
        Student.__count += 1

    @classmethod
    def getCount(cls):       # cls比Student的可读性、扩展性好
        return cls.__count

    def getNums(self):
        return Student.__count


s1 = Student('老王', 40)
s2 = Student('小绿', 20)
print(s1.getNums())
print(Student.getCount())
```
2. 静态方法
* 定义：使用装饰器@staticmethod。参数随意，没有“self”和“cls”参数，但是方法体中不能使用类或实例的任何属性和方法；
* 调用：实例对象和类对象都可以调用。
* 作用：这种方法不会对类和类的对象造成影响，它们的出现仅仅是为了方便，否则它们只能孤零零的出现在代码的其它地方，影响代码的逻辑性。
#####例子：
```cython
import uuid

class Student:

    def __init__(self, name, age):
        self.name = name
        self.age = age
        self.uid = self.getUid()

    @staticmethod
    def getUid():
        uid = str(uuid.uuid1()).replace('-', '')
        return uid

s = Student('小白', 19)
print(s.uid)
```

###1.2类的约束
1. 总结: 约束 其实就是父类对子类进行约束. 子类必须要写xxx方法. 在python中约束的方式和方法有两种:
* 使用抽象类和抽象方法
* 使用人为抛出异常的方案. 并且尽量抛出的是NotImplementError. 这样比较专业, 而且错误比较明确.(推荐)
#####例子
```cython
##################################### 类的约束 ##############################
# 老王和小白的故事

class QQpay:
    def pay(self,money):
        print('使用qq支付%s元' % money)

class Alipay:
    def pay(self,money):
        print('使用支付宝支付%s元' % money)

# a = Alipay()
# a.pay(100)
# b = QQpay()
# b.pay(200)


###################################### 02
# 老王把功能完善

class QQpay:
    def pay(self,money):
        print('使用qq支付%s元' % money)

class Alipay:
    def pay(self,money):
        print('使用支付宝支付%s元' % money)

def pay(obj,money):  # 这个函数就是统一支付规则，这个叫做： 归一化设计。
    obj.pay(money)

# a = Alipay()
# b = QQpay()
# pay(a,100)
# pay(b,200)

############################################# 03 新的需求
# 小白来写新的需求

class QQpay:
    def pay(self,money):
        print('使用qq支付%s元' % money)

class Alipay:
    def pay(self,money):
        print('使用支付宝支付%s元' % money)

class Wechatpay:  # 野生程序员一般不会看别人怎么写，自己才是最好，结果......
    def zhifu(self,money):
        print('使用微信支付%s元' % money)

def pay(obj,money):
    obj.pay(money)

# a = Alipay()
# b = QQpay()
# pay(a,100)
# pay(b,200)
# c = Wechatpay()
# c.zhifu(300)

############################################ 04 完善限制
# 老王加班

class Payment:
    """
    此类什么都不做，就是制定一个标准，谁继承我，必须定义我里面的方法。
    """
    def pay(self,money):
        pass

class QQpay(Payment):
    def pay(self,money):
        print('使用qq支付%s元' % money)

class Alipay(Payment):
    def pay(self,money):
        print('使用支付宝支付%s元' % money)

class Wechatpay(Payment):  # 小白没看文档直接继承了Payment
    def zhifu(self,money):
        print('使用微信支付%s元' % money)

def pay(obj,money):
    obj.pay(money)

# a = Alipay()
# b = QQpay()
# c = Wechatpay()
# pay(a,100)
# pay(b,200)
# pay(c,300)       # 测试未发现异常，但付款没成功

############################################ 05 继续完善

class Payment:
    """
    此类什么都不做，就是制定一个标准，谁继承我，必须定义我里面的方法。
    """
    def pay(self,money):
        raise Exception("你没有实现pay方法")    # 老王想到一个绝妙的方法。。。

class QQpay(Payment):
    def pay(self,money):
        print('使用qq支付%s元' % money)

class Alipay(Payment):
    def pay(self,money):
        print('使用支付宝支付%s元' % money)

class Wechatpay(Payment):
    def zhifu(self,money):
        print('使用微信支付%s元' % money)

    def pay(self,money):
        print('使用微信支付%s元' % money)

def pay(obj,money):
    obj.pay(money)

# a = Alipay()
# b = QQpay()
# c = Wechatpay()
# pay(a,100)
# pay(b,200)
# pay(c,300)

######################################## 抽象类

from abc import ABCMeta,abstractmethod

class Payment(metaclass=ABCMeta):    # 抽象类 接口类  规范和约束  metaclass指定的是一个元类
    @abstractmethod
    def pay(self, m): # 抽象方法
        pass

class Alipay(Payment):
    def pay(self,money):
        print('使用支付宝支付了%s元'%money)

class QQpay(Payment):
    def pay(self,money):
        print('使用qq支付了%s元'%money)

class Wechatpay(Payment):
    def pay(self,money):
        print('使用微信支付了%s元'%money)
    def recharge(self):
        pass

def pay(a,money):
    a.pay(money)

# a = Alipay()
# b = QQpay()
# c = Wechatpay()
# pay(a,100)
# pay(b,200)
# pay(c,300)
```
###1.3 isinstance和issubclass
```cython
class StrNew(str):

    @property
    def len(self):

        return len(self)

s = StrNew('老王上山去砍柴')
print(s, type(s))              # type查看该对象是谁的实例
# isinstance检查该实例对象是否是由某个类（或者某类的父类、父类的父类等）实例化出来的
# 第一个参数是实例化对象，第二个参数是类对象
print(isinstance(s, StrNew), isinstance(s, str), isinstance(s, object))
# 检查两个类是否有继承关系
# 两个参数传入的都是类对象
print(issubclass(StrNew, str), issubclass(StrNew, object), issubclass(str, object))

from typing import Iterable, Iterator
print(isinstance('abc', Iterable))
print(isinstance('abc', Iterator), isinstance(iter('abc'), Iterator))
```
###1.4反射
1. python面向对象中的反射：通过字符串的形式操作对象相关的属性。
2. 反射有hasattr()/getattr()/setattr()/delattr()四种方法
* 例子：
```cython
class Foo:
    f = '类的静态变量'

    def __init__(self,name,age):
        self.name=name
        self.age=age

    def say_hi(self):
        print('hi,%s'%self.name)

obj=Foo('小白',23)
#检测是否含有某属性
print(hasattr(obj,'name'))
print(hasattr(obj,'say_hi'))
print(hasattr(obj, 'hihi'))
#获取属性
n=getattr(obj,'name')
print(n)
func=getattr(obj,'say_hi')
func()
# print(getattr(obj,'aaaaaaaa')) #报错
print(getattr(obj,'aaaaaaaa','不存在啊')) #不报错,返回错误信息
#设置属性
def fun(self):
    print(self.name*20)
Foo.ff = fun         # 动态绑定方法
obj.ff()
setattr(obj,'is_boy',True)
setattr(obj,'show_name',lambda self:self.name+'去小黑家串门')
print(obj.__dict__)
print(obj.show_name(obj))
#删除属性
delattr(obj,'age')
delattr(obj,'show_name')
# delattr(obj,'show_name111') #不存在,则报错
print(obj.__dict__)
```
3. 反射的应用场景
* 例子：
```cython
class User:
    def login(self):
        print('欢迎来到登录页面')

    def register(self):
        print('欢迎来到注册页面')

    def save(self):
        print('欢迎来到存储页面')

# 之前
def choose_01():
    u = User()
    while True:
        choose = input('>>>').strip()
        if choose == 'login':
            u.login()
        elif choose == 'register':
            u.register()
        elif choose == 'save':
            u.save()

# 之后
def choose_02():
    u = User()
    while True:
        choose = input('>>>').strip()
        if hasattr(u, choose):
            func = getattr(u, choose)
            func()
            
``` 

